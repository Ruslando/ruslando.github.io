export const projectsData = {
  'quake-path-tracing': {
    id: 'quake-path-tracing',
    title: 'Bachelor Thesis: Implementing a Hardware-Accelerated Path Tracing Renderer in \'Quake\'',
    subtitle: 'March 4, 2022',
    year: 'March 4, 2022',
    technologies: ['Vulkan', 'C', 'GLSL', 'Ray Tracing', 'Path Tracing'],
    description: `During my studies, I completed a course on "Game Technologies and Interactive Systems: Ray Tracing" that introduced me to the fascinating world of real-time graphics and light simulation. Nvidia's impressive Quake II RTX showcase demonstrated the dramatic visual improvements possible when replacing traditional rasterization with path tracing. Inspired by these developments, I became determined to create my own implementation in a different game engine, ultimately leading to my bachelor's thesis topic.<br><br>My thesis aimed to explore both the possibilities and restrictions of such a modification by implementing a hardware-accelerated path tracing renderer for the original Quake. The work demonstrates the practical challenges involved in transitioning legacy game engines to modern rendering paradigms while highlighting the technical complexities that emerged during this early period of consumer ray tracing adoption.<br><br>**Technical Foundation and API Selection**<br><br>The thesis began by establishing the theoretical groundwork, covering ray tracing fundamentals, path tracing algorithms, and acceleration structures. A crucial early decision involved selecting both the graphics API and the target game for modification. In 2022, only two APIs offered hardware ray tracing support: Microsoft's DirectX Raytracing (DXR) and Khronos Group's Vulkan Ray Tracing extensions.<br><br>After careful analysis, I chose Vulkan for its cross-platform compatibility and vkQuake as the base engine. This decision proved strategic since vkQuake already provided a solid Vulkan foundation, allowing me to focus on ray tracing implementation rather than API porting. The alternative games I considered - Half-Life and The Elder Scrolls III: Morrowind - would have required complete graphics API rewrites, significantly expanding the project scope beyond thesis constraints.<br><br>**Fundamental Architecture Challenges**<br><br>One of the biggest challenges of the implementation was overhauling the rendering pipeline, as rasterization-based rendering and ray tracing are fundamentally different approaches. Many systems built into the game were never designed for ray tracing usage and required complete rewrites, such as Quake's PVS (Potentially Visible Set) system, which culled non-visible geometry.<br><br>Although marvelous at the time, this approach caused significant problems for ray tracing because it removed geometry necessary for correct global illumination calculations, leading to light leaks and other graphical artifacts. Rays can travel in any direction within the scene, potentially intersecting with geometry that the PVS system had deemed "invisible" from the player's current viewpoint.<br><br>Beyond the PVS issues, the transition required fundamental data structure changes. Traditional draw calls process objects sequentially, binding appropriate shaders and parameters for each element. Ray tracing, however, requires all scene elements to be simultaneously accessible since any dispatched ray might intersect with any piece of geometry. This necessitated creating unified buffer structures for both static world geometry and dynamic objects like characters and moving platforms.<br><br>**Implementation Approach**<br><br>I developed a brute-force Monte Carlo path tracing solution using uniform hemisphere sampling. Since Quake didn't have any material information embedded anywhere, this resulted in diffuse scattering, which however worked surprisingly well given the game's art style. The implementation featured three main shader types: ray generation shaders for initial ray dispatch, closest hit shaders for processing geometry intersections, and miss shaders for handling rays that struck no geometry.<br><br>A custom vertex structure unified all geometry types, containing world positions, texture coordinates, texture indices, and material information. Static geometry was loaded once at level initialization into persistent acceleration structures, while dynamic geometry required per-frame reconstruction to accommodate moving objects and animated models.<br><br>Light emission detection proved particularly creative given Quake's limited lighting model. I analyzed the relative luminance of "fullbright" textures - originally designed as unlit decorative elements - treating surfaces exceeding a luminance threshold as light sources. This approach allowed the path tracer to identify light-emitting surfaces like lamps and screens without requiring extensive level data modification.<br><br>**Results and Limitations**<br><br>The implementation successfully demonstrated path tracing feasibility in a classic game engine, producing impressive results in well-lit scenarios. At 512 samples per pixel, outdoor scenes showed convincing soft shadows, natural light distribution, and accurate global illumination. Performance ranged from 144 FPS at low sample counts (2 samples per pixel) to approximately 20 FPS with 64 samples.<br><br>However, the naive sampling approach revealed significant limitations in challenging lighting conditions. Dark indoor environments with small light sources produced predominantly black images even at high sample counts, as uniform hemisphere sampling rarely struck the limited light sources. This highlighted the critical importance of advanced techniques like Next Event Estimation and Multiple Importance Sampling for practical implementations.<br><br>The absence of denoising solutions meant relying entirely on high sample counts for acceptable image quality, while the lack of a physically-based material system treated all surfaces as diffuse. These limitations, combined with remaining PVS-related issues for dynamic objects, prevented the implementation from reaching production-ready quality.`,
    links: {
    }
  }
}

export type Project = typeof projectsData[keyof typeof projectsData]